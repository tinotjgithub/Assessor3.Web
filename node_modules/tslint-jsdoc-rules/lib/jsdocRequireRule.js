"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ts = require("typescript");
var Lint = require("tslint/lib/lint");
var Rule = (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        _super.apply(this, arguments);
    }
    Rule.prototype.apply = function (sourceFile) {
        return this.applyWithWalker(new JsdocCommentsWalker(sourceFile, this.getOptions()));
    };
    Rule.metadata = {
        ruleName: "jsdoc-require",
        description: "Requires JSDoc comments for class members, interfaces and functions.",
        rationale: "Making sure that all code elements are well documented improves code" +
            " readability. It also helps with JSDoc generation as well as transpilation" +
            " to compilers like Google's closure.",
        optionsDescription: (_a = ["\n              Two arguments may be optionally provided:\n            * `\"no-methods\"` excludes JSDoc comments on interface specifications and class methods\n            * `\"no-constructors\"` excludes JSDoc comments on class constructors\n            * `\"no-properties\"` excludes JSDoc comments on class properties\n            * `\"no-functions\"` excludes JSDoc comments on all functions\n            * `\"no-protected\"` excludes JSDoc comments on protected elements\n            * `\"no-private\"` excludes JSDoc comments on private elements\n            * `\"no-private-properties\"` excludes private properties from enforcing JSDoc comments."], _a.raw = ["\n              Two arguments may be optionally provided:\n            * \\`\"no-methods\"\\` excludes JSDoc comments on interface specifications and class methods\n            * \\`\"no-constructors\"\\` excludes JSDoc comments on class constructors\n            * \\`\"no-properties\"\\` excludes JSDoc comments on class properties\n            * \\`\"no-functions\"\\` excludes JSDoc comments on all functions\n            * \\`\"no-protected\"\\` excludes JSDoc comments on protected elements\n            * \\`\"no-private\"\\` excludes JSDoc comments on private elements\n            * \\`\"no-private-properties\"\\` excludes private properties from enforcing JSDoc comments."], Lint.Utils.dedent(_a)),
        options: {
            type: "array",
            items: {
                type: "string",
                enum: ["methods", "properties", "functions", "protected", "public", "no-private-properties"],
            },
            minLength: 0,
            maxLength: 6,
        },
        optionExamples: ["true", '[true, "methods", "protected"]'],
        type: "typescript",
    };
    Rule.FAILURE_STRING_FACTORY = function (memberType, memberName) {
        memberName = memberName == null ? "" : " '" + memberName + "'";
        return "Missing JSDoc element for " + memberType + memberName + "'";
    };
    return Rule;
    var _a;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
var JsdocCommentsWalker = (function (_super) {
    __extends(JsdocCommentsWalker, _super);
    function JsdocCommentsWalker() {
        _super.apply(this, arguments);
    }
    JsdocCommentsWalker.prototype.visitConstructorDeclaration = function (node) {
        if (!this.hasOption("no-constructors")) {
            this.validateJsDocComment(node);
        }
        _super.prototype.visitConstructorDeclaration.call(this, node);
    };
    JsdocCommentsWalker.prototype.visitMethodSignature = function (node) {
        if (!this.hasOption("no-methods")) {
            this.validateJsDocComment(node);
        }
        _super.prototype.visitMethodSignature.call(this, node);
    };
    JsdocCommentsWalker.prototype.visitFunctionDeclaration = function (node) {
        if (!this.hasOption("no-functions")) {
            this.validateJsDocComment(node);
        }
        _super.prototype.visitFunctionDeclaration.call(this, node);
    };
    JsdocCommentsWalker.prototype.visitMethodDeclaration = function (node) {
        if (!this.hasOption("no-methods")) {
            this.validateJsDocComment(node);
        }
        _super.prototype.visitMethodDeclaration.call(this, node);
    };
    JsdocCommentsWalker.prototype.visitPropertyDeclaration = function (node) {
        if (!this.hasOption("no-properties")) {
            this.validateJsDocComment(node);
        }
        _super.prototype.visitPropertyDeclaration.call(this, node);
    };
    JsdocCommentsWalker.prototype.validateJsDocComment = function (node) {
        var hasPrivateModifiers = Lint.hasModifier(node.modifiers, ts.SyntaxKind.PrivateKeyword);
        var hasProtectedModifiers = Lint.hasModifier(node.modifiers, ts.SyntaxKind.ProtectedKeyword);
        if ((this.hasOption("no-protected") && hasProtectedModifiers) ||
            (this.hasOption("no-private") && hasPrivateModifiers) ||
            (this.hasOption("no-private-properties") && hasPrivateModifiers &&
                node.kind === ts.SyntaxKind.PropertyDeclaration)) {
            return;
        }
        var comment = this.getJsDocCommentsFromText(node, this.getSourceFile().text);
        if (comment && comment.length) {
            return;
        }
        var memberType;
        switch (node.kind) {
            case ts.SyntaxKind.MethodSignature:
                memberType = "interface declaration";
                break;
            case ts.SyntaxKind.FunctionDeclaration:
                memberType = "function declaration";
                break;
            case ts.SyntaxKind.MethodDeclaration:
                memberType = "class method";
                break;
            case ts.SyntaxKind.PropertyDeclaration:
                memberType = "class property";
                break;
            case ts.SyntaxKind.Constructor:
                memberType = "class constructor";
                break;
            default:
                memberType = "";
        }
        if (hasPrivateModifiers) {
            memberType = "private " + memberType;
        }
        if (hasProtectedModifiers) {
            memberType = "protected " + memberType;
        }
        var memberName;
        node.getChildren().forEach(function (n) {
            if (n.kind === ts.SyntaxKind.Identifier) {
                memberName = n.getText();
            }
        });
        var failureString = Rule.FAILURE_STRING_FACTORY(memberType, memberName);
        this.addFailure(this.createFailure(node.getStart(), node.getWidth(), failureString));
    };
    JsdocCommentsWalker.prototype.getJsDocCommentsFromText = function (node, text) {
        var commentRanges = (node.kind === ts.SyntaxKind.Parameter ||
            node.kind === ts.SyntaxKind.TypeParameter ||
            node.kind === ts.SyntaxKind.FunctionExpression ||
            node.kind === ts.SyntaxKind.ArrowFunction) ?
            getCommentRanges(text, node.pos, false).concat(getCommentRanges(text, node.pos, true)) :
            getCommentRanges(text, node.pos, false);
        return commentRanges ? commentRanges.filter(isJsDocComment) : [];
        function isJsDocComment(comment) {
            return text.charCodeAt(comment.pos + 1) === "*".charCodeAt(0) &&
                text.charCodeAt(comment.pos + 2) === "*".charCodeAt(0) &&
                text.charCodeAt(comment.pos + 3) !== "/".charCodeAt(0);
        }
        function isWhiteSpace(ch) {
            return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);
        }
        function isWhiteSpaceSingleLine(ch) {
            return ch === 32 ||
                ch === 9 ||
                ch === 11 ||
                ch === 12 ||
                ch === 160 ||
                ch === 133 ||
                ch === 5760 ||
                ch >= 8192 && ch <= 8203 ||
                ch === 8239 ||
                ch === 8287 ||
                ch === 12288 ||
                ch === 65279;
        }
        function isLineBreak(ch) {
            return ch === 10 ||
                ch === 13 ||
                ch === 8232 ||
                ch === 8233;
        }
        function lastOrUndefined(array) {
            if (array.length === 0) {
                return undefined;
            }
            return array[array.length - 1];
        }
        function getCommentRanges(text, pos, trailing) {
            var result;
            var collecting = trailing || pos === 0;
            while (pos < text.length) {
                var ch = text.charCodeAt(pos);
                switch (ch) {
                    case 13:
                        if (text.charCodeAt(pos + 1) === 10) {
                            pos++;
                        }
                    case 10:
                        pos++;
                        if (trailing) {
                            return result;
                        }
                        collecting = true;
                        if (result && result.length) {
                            lastOrUndefined(result).hasTrailingNewLine = true;
                        }
                        continue;
                    case 9:
                    case 11:
                    case 12:
                    case 32:
                        pos++;
                        continue;
                    case 47:
                        var nextChar = text.charCodeAt(pos + 1);
                        var hasTrailingNewLine = false;
                        if (nextChar === 47 || nextChar === 42) {
                            var kind = nextChar === 47 ?
                                ts.SyntaxKind.SingleLineCommentTrivia :
                                ts.SyntaxKind.MultiLineCommentTrivia;
                            var startPos = pos;
                            pos += 2;
                            if (nextChar === 47) {
                                while (pos < text.length) {
                                    if (isLineBreak(text.charCodeAt(pos))) {
                                        hasTrailingNewLine = true;
                                        break;
                                    }
                                    pos++;
                                }
                            }
                            else {
                                while (pos < text.length) {
                                    if (text.charCodeAt(pos) === 42 && text.charCodeAt(pos + 1) === 47) {
                                        pos += 2;
                                        break;
                                    }
                                    pos++;
                                }
                            }
                            if (collecting) {
                                if (!result) {
                                    result = [];
                                }
                                result.push({ pos: startPos, end: pos, hasTrailingNewLine: hasTrailingNewLine, kind: kind });
                            }
                            continue;
                        }
                        break;
                    default:
                        if (ch > 127 && (isWhiteSpace(ch))) {
                            if (result && result.length && isLineBreak(ch)) {
                                lastOrUndefined(result).hasTrailingNewLine = true;
                            }
                            pos++;
                            continue;
                        }
                        break;
                }
                return result;
            }
            return result;
        }
    };
    return JsdocCommentsWalker;
}(Lint.RuleWalker));
exports.JsdocCommentsWalker = JsdocCommentsWalker;
